<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lexar</title>
</head>
<script> //PEMDAS //SADMEP
var deliminters = new RegExp(/([*|/|+|\-|^|)|(])/);
const numbers = new RegExp(/([0-9])/);
var invalidToken = new RegExp(/([a-zA-Z]+)/);
var brackets = [new RegExp(/[(]/), new RegExp(/[)]/)];
var isString = new RegExp(/"/);
function calculate(){
  var newExpression = document.getElementById("expression").value;
  console.log(getPrecedence("("));
  var newTokens = tokenizer(newExpression); //converts expression from postfix to infix
  document.getElementById("postfixed").innerHTML = "<p>" + newTokens.join(" ") + "</p>";
  var newTokenTree = parseTokens(newTokens);
  console.log(newTokenTree);
  document.getElementById("results").innerHTML = "<p>Results = " + newTokenTree.Eval() + "</p>";

}
function parseTokens(expressionArray){
  var newNumberStack = new Stack;
  for(var index = 0; index < expressionArray.length; index++){
      var token = expressionArray[index];
      // console.log("token = ", token);
      
      var newNode = new Node(token);
      if(newNode.type === "num"){
        newNumberStack.push(newNode);
      }else if(newNode.type === "operator"){
          newNode.rightNode = newNumberStack.pop();
          newNode.leftNode = newNumberStack.pop();
          newNumberStack.push(newNode);
        }
        // console.log(newNode);
      }
      // console.log(newNode); 
    return newNode;
}
function tokenizer(expression){
    expression = expression.split(deliminters);
    expression = removeEmptyIndices(expression);
    // console.log(expression);
    var postFixed = new Array();
    var operationStack = new Stack();
    for(var index = 0; index < expression.length; index++){
      var token = expression[index];
      // console.log("token = " + token);
      // console.log(brackets[0].test(token), brackets[1].test(token));
      // var newNode = new Node(token);
      // console.log("newNode Data : ", newNode.value, newNode.type);
      if(numbers.test(token)){ //if number
        postFixed.push(token)
      }else if(brackets[0].test(token)){ //if open brackets
        operationStack.push(token);
      }
      else if(brackets[1].test(token)){ //if closing brackers
        while(operationStack.peek() !== "("){
          postFixed.push(operationStack.pop());
        }
        operationStack.pop();
      }
      else{
        // console.log(eval(getPrecedence(operationStack.peek()) >= getPrecedence(token)));
        while(getPrecedence(operationStack.peek()) >= getPrecedence(token)){
          postFixed.push(operationStack.pop());
        }
        operationStack.push(token);
      }
    }
    while(typeof(operationStack.peek()) !== "undefined"){
      postFixed.push(operationStack.pop());
    }
    // console.log(postFixed);
  return postFixed;
}
function getPrecedence(value){
        switch(value){ //PEMDAS
            case "^": return 4;
            case "/": return 2;
            case "*": return 2;
            case "+": return 1;
            case "-": return 1;
            case "(": return 0;
        } 
}
class Stack{
  top;
  newStack;
  constructor(){
    this.newStack = [];
    this.top = -1;
  }
  push(data){
    this.top++;
    this.newStack[this.top] = data;
  }
  pop(){
    var newData = this.newStack[this.top];
    this.top--;
    return newData;
  }
  peek(){
    return this.newStack[this.top];
  }
}
class Node {
    leftNode;
    rightNode;
    value;
    type;
    constructor(value){
        this.value = value;
        if(deliminters.test(this.value)) {
            this.type = "operator";
            if(brackets[0].test(this.value)){
                this.type = "openBraces";
            }
            if(brackets[1].test(this.value)){
                this.type = "closingBraces";
            }
        }
        else if(numbers.test(this.value)){
            this.value = Number(this.value);
            this.type = "num";
        }
    }
    Precedence(){
        switch(this.value){ //PEMDAS
            case "^": return 4;
            case "/": return 2;
            case "*": return 2;
            case "+": return 1;
            case "-": return 1;
            case "(": return 0;
        } 
    }
    Eval(){
        if(this.type === "num"){
            return this.value;
        }else if(this.type === "operator"){
                switch(this.value){
                case "^": return Math.pow(this.leftNode.Eval(), this.rightNode.Eval());
                case "*": return this.leftNode.Eval() * this.rightNode.Eval();
                case "/": return this.leftNode.Eval() / this.rightNode.Eval();
                case "+": return this.leftNode.Eval() + this.rightNode.Eval();
                case "-": return this.leftNode.Eval() - this.rightNode.Eval();
            } 
        }
    }
}
function sliceArray(array, start, end){ //returns a stack of statements as an array
  var newArray = new Array();
  for(index = start; index <= end; index++){
    newArray.push(array[index]);
  }
  return newArray;
}
function findMatching(array, start, token) { //token = "(" pr "{"
  //raw string -> breakIntoComponents() first. start is the index of the array where a function declartion is detected.
  var token_2 = null;
  if(token === "{"){
    token_2 = "}";
  }else if(token === "("){
    token = (/([(])/);
    token_2 = (/([)])/);
  }
  var count = 0;
  var endLine = -1;
  for (index = start; index < array.length; index++) {
    if (array[index].search(token) > -1) {
      count = count + 1;
    }
    if (array[index].search(token_2) > -1) {
      count = count - 1;
    }
    if (count === 0 && array[index].search(token_2) > -1) {
      endLine = index;
      break;
    }
    // console.log(count);
  }
  return endLine;
}
function removeEmptyIndices(array) {
  //clean array if nothing is detected on indexes
  var newArray = new Array();
  for (index = 0; index < array.length; index++) {
    if (!(array[index].trim().length === 0)) {
      newArray.push(array[index]);
    }
  }
  return newArray;
}
</script>
<body>
<input type="text" id="expression" class="label" value="(10+5^2)*((5*2)+9-3^3 )/ 2">
<button onclick="calculate()">Calculate</button>
<div id="postfixed"></div>
<div id="results"></div>
</body>
</html>